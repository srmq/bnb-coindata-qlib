import json
import asyncio
from pathlib import Path
import csv
import argparse
import datetime
import pytz

async def main():

    argParser = argparse.ArgumentParser()
    argParser.add_argument('--source_dir_1d', help='Source directory for 1d data in bnbFetchCoinData CSV format')
    argParser.add_argument('--source_dir_1m', help='Source directory for 1m data in bnbFetchCoinData CSV format')
    argParser.add_argument('--output_dir_1d', help='Output directory for 1d data in qlib CSV format')
    argParser.add_argument('--output_dir_1m', help='Output directory for 1m data in qlib CSV format')
    argParser.add_argument('--coin_meta', help='Path for JSON file with coin metadata generated by bnbFetchCoinData')

    args = argParser.parse_args()
    if args.source_dir_1d is None:
        raise ValueError('argument for --source_dir_1d is mandatory')
    if args.source_dir_1m is None:
        raise ValueError('argument for --source_dir_1m is mandatory')
    if args.output_dir_1d is None:
        raise ValueError('argument for --output_dir_1d is mandatory')
    if args.output_dir_1m is None:
        raise ValueError('argument for --output_dir_1m is mandatory')
    if args.coin_meta is None:
        raise ValueError('argument for --coin_meta is mandatory')
    

    output1m = Path(args.output_dir_1m)
    if (output1m.exists()):
        if not output1m.is_dir():
            raise ValueError('argument for --output_dir_1m exists but is not a directory')
    else:
        output1m.mkdir(parents=True)

    output1d = Path(args.output_dir_1d)
    if (output1d.exists()):
        if not output1d.is_dir():
            raise ValueError('argument for --output_dir_1d exists but is not a directory')
    else:
        output1d.mkdir(parents=True)

    input1m = Path(args.source_dir_1m)
    if not input1m.is_dir():
        raise ValueError('argument for --source_dir_1m is not a directory')

    input1d = Path(args.source_dir_1d)
    if not input1d.is_dir():
        raise ValueError('argument for --source_dir_1d is not a directory')

    coinMetaFile = Path(args.coin_meta)
    if not coinMetaFile.is_file():
        raise ValueError('argument for --coin_meta is not a file')


    coinMeta = {}
    with open(coinMetaFile) as jsonFile:
        coinMeta = json.load(jsonFile)
    for symbol in coinMeta['exchange-info']['symbols']:
        symbolCSV1m = input1m / (symbol['symbol'] + '.csv')
        if symbol['quoteAsset'] == 'USDT' and symbolCSV1m.is_file():
            lotSizeMinQty = 0
            lotSizeStepSize = 0
            for filter in symbol['filters']:
                if filter['filterType'] == 'LOT_SIZE':
                    lotSizeMinQty = float(filter['minQty'])
                    lotSizeStepSize = float(filter['stepSize'])
                    if lotSizeMinQty != lotSizeStepSize:
                        print('Warning minqty is %f while stepsize is %f'%(lotSizeMinQty, lotSizeStepSize))
                    break
            print('Have data for: %s. Minimum lot is %f'%(symbol['symbol'], lotSizeMinQty))
            symbolCSV1d = input1d / (symbol['symbol'] + '.csv')
            if symbolCSV1d.is_file():
                # doing 1m data
                with open(symbolCSV1m, newline='') as csvfile:
                    csvReader1m = csv.DictReader(csvfile, delimiter=',')
                    # csv lines have the following columns
                    # [0]  - Open time
                    # [1]  - Open
                    # [2]  - High
                    # [3]  - Low
                    # [4]  - Close
                    # [5]  - Volume
                    # [6]  - Close time
                    # [7]  - Quote asset volume
                    # [8]  - Number of trades
                    # [9]  - Taker buy base asset volume
                    # [10] - Taker buy quote asset volume
                    # [11] - Ignore
                    # qlib csv format should be like (for 1m data)...
                    # symbol,date,open,high,low,close,volume,vwap
                    # sz000001,2021-11-15 09:30:00,18.459999084472656,18.479999542236328,2029253.0,18.3799991607666,18.3799991607666
                    #
                    # and for 1d data...
                    # symbol,date,volume,high,close,open,low,adjclose,vwap
                    # sz000301,2020-11-02,13827112,6.539999961853027,6.5,6.170000076293945,6.170000076293945,6.459374904632568
                    #
                    # whereas bnbFetchCoinData is like...
                    # Open time, Open, High, Low, Close, Volume, Close time, Quote asset volume, Number of trades, Taker buy base asset volume, Taker buy quote asset volume, Ignore
                    # 1502942400000, 4261.48000000, 4261.48
                    #
                    # mapping from bnbFetchCoinData will be like...
                    #
                    # symbol['symbol'] -> symbol
                    # Open time (formatted as datetime/date) -> date
                    # Open*lotSizeMinQty -> open
                    # Close*lotSizeMinQty -> close
                    # Volume/lotSizeMinQty -> volume
                    # High*lotSizeMinQty -> high
                    # Low*lotSizeMinQty -> low
                    # Quote asset volume / Volume -> vwap
                    outputCSV1m = output1m / (symbol['symbol'] + '.csv')
                    with open( outputCSV1m, 'w', newline='') as outputCSVFile1m:
                        fieldnames = ['symbol', 'date', 'open', 'close', 'high', 'low', 'volume', 'vwap']
                        writer1m = csv.DictWriter(outputCSVFile1m, fieldnames=fieldnames)
                        writer1m.writeheader()
                        for row in csvReader1m:
                            writer1m.writerow({
                                'symbol': symbol['symbol'],
                                'date': datetime.datetime.fromtimestamp(float(row['Open time'])/1000.0, tz=pytz.utc).strftime('%Y-%m-%dT%H:%M:%SZ'),
                                'open' :  float(row['Open'])*lotSizeMinQty,
                                'close' : float(row['Close'])*lotSizeMinQty,
                                'high' : float(row['High'])*lotSizeMinQty,
                                'low' : float(row['Low'])*lotSizeMinQty,
                                'volume' : float(row['Volume'])/lotSizeMinQty,
                                'vwap': float(row['Quote asset volume'])/(float(row['Volume'])+1.0e-12)
                                })
                # doing 1d data
                with open(symbolCSV1d, newline='') as csvfile:
                    csvReader1d = csv.DictReader(csvfile, delimiter=',')
                    outputCSV1d = output1d / (symbol['symbol'] + '.csv')
                    with open( outputCSV1d, 'w', newline='') as outputCSVFile1d:
                        fieldnames = ['symbol', 'date', 'open', 'close', 'high', 'low', 'volume', 'vwap']
                        writer1d = csv.DictWriter(outputCSVFile1d, fieldnames=fieldnames)
                        writer1d.writeheader()
                        for row in csvReader1d:
                            writer1d.writerow({
                                'symbol': symbol['symbol'],
                                'date': datetime.datetime.fromtimestamp(float(row['Open time'])/1000.0, tz=pytz.utc).strftime('%Y-%m-%d'),
                                'open' :  float(row['Open'])*lotSizeMinQty,
                                'close' : float(row['Close'])*lotSizeMinQty,
                                'high' : float(row['High'])*lotSizeMinQty,
                                'low' : float(row['Low'])*lotSizeMinQty,
                                'volume' : float(row['Volume'])/lotSizeMinQty,
                                'vwap': float(row['Quote asset volume'])/(float(row['Volume'])+1.0e-12)
                                })




            else:
                raise ValueError(f"could not find 1d data for {symbol['symbol']}")

            


if __name__ == "__main__":
    asyncio.run(main())
